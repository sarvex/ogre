<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Manual mesh creation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">13.6</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('manual-mesh-creation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Manual mesh creation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_tutorials_manualmesh"></a> There are two ways to create your own mesh. The first way is to create a <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh.">Ogre::Mesh</a> instance and provide it with the vertex and index buffers directly.</p>
<p>The second way is the high level <a class="el" href="class_ogre_1_1_manual_object.html" title="Class providing a much simplified interface to generating manual objects with custom geometry.">Ogre::ManualObject</a> interface. Instead of filling position and color buffers, you simply call the "position" and "colour" functions.</p>
<h1><a class="anchor" id="autotoc_md305"></a>
Using Manual Object</h1>
<p>Building one-off geometry objects manually usually requires getting down and dirty with the vertex buffer and vertex declaration API, which some people find a steep learning curve. This class gives you a simpler interface specifically for the purpose of building a 3D object simply and quickly. Note that if you intend to instance your object you will still need to become familiar with the Mesh class.</p>
<p>This class draws heavily on the interface for OpenGL immediate-mode (<code>glBegin</code>, <code>glVertex</code>, <code>glNormal</code> etc), since this is generally well-liked by people. There are a couple of differences in the results though - internally this class still builds hardware buffers which can be re-used, so you can render the resulting object multiple times without re-issuing all the same commands again. Secondly, the rendering is not immediate, it is still queued just like all OGRE objects. This makes this object more efficient than the equivalent GL immediate-mode commands, so it's feasible to use it for large objects if you really want to.</p>
<p>To construct some geometry with this object:</p><ol type="1">
<li>If you know roughly how many vertices (and indices, if you use them) you're going to submit, call estimateVertexCount() and estimateIndexCount(). This is not essential but will make the process more efficient by saving memory reallocations.</li>
<li>Call begin() to begin entering data</li>
<li>For each vertex, call position(), normal(), textureCoord(), colour() to define your vertex data. Note that each time you call position() you start a new vertex. Note that the first vertex defines the components of the vertex - you can't add more after that. For example if you didn't call normal() in the first vertex, you cannot call it in any others. You ought to call the same combination of methods per vertex.</li>
<li>If you want to define triangles (or lines/points) by indexing into the vertex list, you can call index() as many times as you need to define them. If you don't do this, the class will assume you want triangles drawn directly as defined by the vertex list, i.e. non-indexed geometry. Note that stencil shadows are only supported on indexed geometry, and that indexed geometry is a little faster; so you should try to use it.</li>
<li>Call end() to finish entering data.</li>
<li>Optionally repeat the begin-end cycle if you want more geometry using different rendering operation types, or different materials After calling end(), the class will organise the data for that section internally and make it ready to render with. Like any other MovableObject you should attach the object to a SceneNode to make it visible. Other aspects like the relative render order can be controlled using standard MovableObject methods like setRenderQueueGroup.</li>
</ol>
<p>You can also use beginUpdate() to alter the geometry later on if you wish. If you do this, you should call setDynamic(true) before your first call to begin(), and also consider using estimateVertexCount() / estimateIndexCount() if your geometry is going to be growing, to avoid buffer recreation during growth.</p>
<dl class="section note"><dt>Note</dt><dd>like all OGRE geometry, triangles should be specified in anti-clockwise winding order (whether you're doing it with just vertices, or using indexes too). That is to say that the front of the face is the one where the vertices are listed in anti-clockwise order.</dd></dl>
<h2><a class="anchor" id="autotoc_md306"></a>
Example</h2>
<p>We will use the ManualObject to create a single textured plane. After creating the object, we start a new geometry block that will use the given material</p>
<div class="fragment"><div class="line">    <a class="code" href="class_ogre_1_1_manual_object.html">Ogre::ManualObject</a>* man = mSceneMgr-&gt;createManualObject(<span class="stringliteral">&quot;test&quot;</span>);</div>
<div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a70d5945478fbc7fa056cecd88fdf2781">begin</a>(<span class="stringliteral">&quot;Examples/OgreLogo&quot;</span>, <a class="code" href="class_ogre_1_1_render_operation.html#ab8b780ec18ee4675e85f475b21f77c82a8c00ee152b44fe8000c2fd675437c087">Ogre::RenderOperation::OT_TRIANGLE_LIST</a>);</div>
<div class="ttc" id="aclass_ogre_1_1_manual_object_html"><div class="ttname"><a href="class_ogre_1_1_manual_object.html">Ogre::ManualObject</a></div><div class="ttdoc">Class providing a much simplified interface to generating manual objects with custom geometry.</div><div class="ttdef"><b>Definition:</b> OgreManualObject.h:107</div></div>
<div class="ttc" id="aclass_ogre_1_1_manual_object_html_a70d5945478fbc7fa056cecd88fdf2781"><div class="ttname"><a href="class_ogre_1_1_manual_object.html#a70d5945478fbc7fa056cecd88fdf2781">Ogre::ManualObject::begin</a></div><div class="ttdeci">virtual void begin(const String &amp;materialName, RenderOperation::OperationType opType=RenderOperation::OT_TRIANGLE_LIST, const String &amp;groupName=ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)</div><div class="ttdoc">Start defining a part of the object.</div></div>
<div class="ttc" id="aclass_ogre_1_1_render_operation_html_ab8b780ec18ee4675e85f475b21f77c82a8c00ee152b44fe8000c2fd675437c087"><div class="ttname"><a href="class_ogre_1_1_render_operation.html#ab8b780ec18ee4675e85f475b21f77c82a8c00ee152b44fe8000c2fd675437c087">Ogre::RenderOperation::OT_TRIANGLE_LIST</a></div><div class="ttdeci">@ OT_TRIANGLE_LIST</div><div class="ttdoc">A list of triangles, 3 vertices per triangle.</div><div class="ttdef"><b>Definition:</b> OgreRenderOperation.h:56</div></div>
</div><!-- fragment --><p> Next we specify the vertices of the plane</p>
<div class="fragment"><div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a187c45061916977737747db37e2d17dd">position</a>(-20, 20, 20);</div>
<div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#ae4e167780418393dcfe2f1832c0b3d04">normal</a>(0, 0, 1);</div>
<div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a66932d232441c8fa8208d46343ff526b">textureCoord</a>(0, 0);</div>
<div class="line"> </div>
<div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a187c45061916977737747db37e2d17dd">position</a>(-20, -20, 20);</div>
<div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#ae4e167780418393dcfe2f1832c0b3d04">normal</a>(0, 0, 1);</div>
<div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a66932d232441c8fa8208d46343ff526b">textureCoord</a>(0, 1);</div>
<div class="line"> </div>
<div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a187c45061916977737747db37e2d17dd">position</a>(20, -20, 20);</div>
<div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#ae4e167780418393dcfe2f1832c0b3d04">normal</a>(0, 0, 1);</div>
<div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a66932d232441c8fa8208d46343ff526b">textureCoord</a>(1, 1);</div>
<div class="line"> </div>
<div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a187c45061916977737747db37e2d17dd">position</a>(20, 20, 20);</div>
<div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#ae4e167780418393dcfe2f1832c0b3d04">normal</a>(0, 0, 1);</div>
<div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a66932d232441c8fa8208d46343ff526b">textureCoord</a>(1, 0);</div>
<div class="ttc" id="aclass_ogre_1_1_manual_object_html_a187c45061916977737747db37e2d17dd"><div class="ttname"><a href="class_ogre_1_1_manual_object.html#a187c45061916977737747db37e2d17dd">Ogre::ManualObject::position</a></div><div class="ttdeci">void position(const Vector3 &amp;pos)</div><div class="ttdoc">Add a vertex position, starting a new vertex at the same time.</div><div class="ttdef"><b>Definition:</b> OgreManualObject.h:203</div></div>
<div class="ttc" id="aclass_ogre_1_1_manual_object_html_a66932d232441c8fa8208d46343ff526b"><div class="ttname"><a href="class_ogre_1_1_manual_object.html#a66932d232441c8fa8208d46343ff526b">Ogre::ManualObject::textureCoord</a></div><div class="ttdeci">void textureCoord(float u)</div><div class="ttdoc">Add a texture coordinate to the current vertex.</div><div class="ttdef"><b>Definition:</b> OgreManualObject.h:277</div></div>
<div class="ttc" id="aclass_ogre_1_1_manual_object_html_ae4e167780418393dcfe2f1832c0b3d04"><div class="ttname"><a href="class_ogre_1_1_manual_object.html#ae4e167780418393dcfe2f1832c0b3d04">Ogre::ManualObject::normal</a></div><div class="ttdeci">void normal(const Vector3 &amp;norm)</div><div class="ttdoc">Add a vertex normal to the current vertex.</div><div class="ttdef"><b>Definition:</b> OgreManualObject.h:237</div></div>
</div><!-- fragment --><p> Now we can define the face. Ogre will split the quad into triangles for us.</p>
<div class="fragment"><div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a27ae16d1c958d097a6faa58495e43a22">quad</a>(0, 1, 2, 3);</div>
<div class="ttc" id="aclass_ogre_1_1_manual_object_html_a27ae16d1c958d097a6faa58495e43a22"><div class="ttname"><a href="class_ogre_1_1_manual_object.html#a27ae16d1c958d097a6faa58495e43a22">Ogre::ManualObject::quad</a></div><div class="ttdeci">void quad(uint32 i1, uint32 i2, uint32 i3, uint32 i4)</div><div class="ttdoc">Add a set of 4 vertex indices to construct a quad (out of 2 triangles); this is a shortcut to calling...</div><div class="ttdef"><b>Definition:</b> OgreManualObject.h:408</div></div>
</div><!-- fragment --><p> Calling <code>end()</code> creates the actual Hardware Buffers to be used for rendering and we can attach the Object to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph.">Ogre::SceneNode</a>.</p>
<div class="fragment"><div class="line">    man-&gt;<a class="code" href="class_ogre_1_1_manual_object.html#a49d6bfe460ff1e0178c6d77b95d3dc5a">end</a>();</div>
<div class="line">    mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode()-&gt;attachObject(man);</div>
<div class="ttc" id="aclass_ogre_1_1_manual_object_html_a49d6bfe460ff1e0178c6d77b95d3dc5a"><div class="ttname"><a href="class_ogre_1_1_manual_object.html#a49d6bfe460ff1e0178c6d77b95d3dc5a">Ogre::ManualObject::end</a></div><div class="ttdeci">virtual ManualObjectSection * end(void)</div><div class="ttdoc">Finish defining the object and compile the final renderable version.</div></div>
</div><!-- fragment --><p> In case you need multiple Ogre::Entities of the plane, you should call <a class="el" href="class_ogre_1_1_manual_object.html#a657275e617d9558951a3037f02b07efe" title="Convert this object to a Mesh.">Ogre::ManualObject::convertToMesh</a> first and then use <a class="el" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185" title="Create an Entity (instance of a discrete mesh).">Ogre::SceneManager::createEntity</a> as usual.</p>
<h1><a class="anchor" id="autotoc_md307"></a>
Using vertex and index buffers directly</h1>
<p>This time we are going to create a plane using the lower level <a class="el" href="class_ogre_1_1_hardware_buffer.html" title="Abstract class defining common features of hardware buffers.">Ogre::HardwareBuffer</a> primitives.</p>
<p>We start by creating a Mesh object. As this is a manual Mesh, we have to set the bounds of it explicitly. </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_ogre.html">Ogre</a>;</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="namespace_ogre.html#a5c4c0c56ea9f824c49e331f6fad33ddb">MeshPtr</a> mesh = <a class="code" href="class_ogre_1_1_mesh_manager.html#a2efefa307b7987c5fcff7e8c47f79758">MeshManager::getSingleton</a>().<a class="code" href="class_ogre_1_1_mesh_manager.html#ad99f5f2e2d045e5a4af301974e45c918">createManual</a>(yourMeshName, <a class="code" href="group___resources.html#gaa9ab155dab741621494def41928e03ae">RGN_DEFAULT</a>);</div>
<div class="line">        mesh-&gt;<a class="code" href="class_ogre_1_1_mesh.html#a8c40c34ec7c32009904c0cd730f68b5d">_setBounds</a>(AxisAlignedBox({-100,-100,0}, {100,100,0});</div>
<div class="ttc" id="aclass_ogre_1_1_mesh_html_a8c40c34ec7c32009904c0cd730f68b5d"><div class="ttname"><a href="class_ogre_1_1_mesh.html#a8c40c34ec7c32009904c0cd730f68b5d">Ogre::Mesh::_setBounds</a></div><div class="ttdeci">void _setBounds(const AxisAlignedBox &amp;bounds, bool pad=true)</div><div class="ttdoc">Manually set the bounding box for this Mesh.</div></div>
<div class="ttc" id="aclass_ogre_1_1_mesh_manager_html_a2efefa307b7987c5fcff7e8c47f79758"><div class="ttname"><a href="class_ogre_1_1_mesh_manager.html#a2efefa307b7987c5fcff7e8c47f79758">Ogre::MeshManager::getSingleton</a></div><div class="ttdeci">static MeshManager &amp; getSingleton(void)</div><div class="ttdoc">Get the singleton instance.</div></div>
<div class="ttc" id="aclass_ogre_1_1_mesh_manager_html_ad99f5f2e2d045e5a4af301974e45c918"><div class="ttname"><a href="class_ogre_1_1_mesh_manager.html#ad99f5f2e2d045e5a4af301974e45c918">Ogre::MeshManager::createManual</a></div><div class="ttdeci">MeshPtr createManual(const String &amp;name, const String &amp;groupName, ManualResourceLoader *loader=0)</div><div class="ttdoc">Creates a new Mesh specifically for manual definition rather than loading from an object file.</div></div>
<div class="ttc" id="agroup___resources_html_gaa9ab155dab741621494def41928e03ae"><div class="ttname"><a href="group___resources.html#gaa9ab155dab741621494def41928e03ae">Ogre::RGN_DEFAULT</a></div><div class="ttdeci">_OgreExport const char *const RGN_DEFAULT</div><div class="ttdoc">Default resource group name.</div></div>
<div class="ttc" id="anamespace_ogre_html"><div class="ttname"><a href="namespace_ogre.html">Ogre</a></div><div class="ttdef"><b>Definition:</b> OgreAlignedAllocator.h:34</div></div>
<div class="ttc" id="anamespace_ogre_html_a5c4c0c56ea9f824c49e331f6fad33ddb"><div class="ttname"><a href="namespace_ogre.html#a5c4c0c56ea9f824c49e331f6fad33ddb">Ogre::MeshPtr</a></div><div class="ttdeci">SharedPtr&lt; Mesh &gt; MeshPtr</div><div class="ttdef"><b>Definition:</b> OgrePrerequisites.h:293</div></div>
</div><!-- fragment --><p>Next we define what should end up in our vertex and index buffer. We will store all data interleaved in one buffer. This typically has some advantages due to cache coherency and also is what ManualObject does automatically for us.</p>
<div class="fragment"><div class="line">        <span class="keywordtype">float</span> vertices[32] = {</div>
<div class="line">            -100, -100, 0,  <span class="comment">// pos</span></div>
<div class="line">            0,0,1,          <span class="comment">// normal</span></div>
<div class="line">            0,1,            <span class="comment">// texcoord</span></div>
<div class="line">            100, -100, 0,</div>
<div class="line">            0,0,1,</div>
<div class="line">            1,1,</div>
<div class="line">            100,  100, 0,</div>
<div class="line">            0,0,1,</div>
<div class="line">            1,0,</div>
<div class="line">            -100,  100, 0 ,</div>
<div class="line">            0,0,1,</div>
<div class="line">            0,0 </div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="namespace_ogre.html#a2a820cf8746c0f12999d2416c767f55d">uint16</a> faces[6] = {0,1,2,</div>
<div class="line">                           0,2,3 };</div>
<div class="ttc" id="anamespace_ogre_html_a2a820cf8746c0f12999d2416c767f55d"><div class="ttname"><a href="namespace_ogre.html#a2a820cf8746c0f12999d2416c767f55d">Ogre::uint16</a></div><div class="ttdeci">uint16_t uint16</div><div class="ttdef"><b>Definition:</b> OgrePlatform.h:271</div></div>
</div><!-- fragment --><p> However we could also split the data into multiple buffers with lower precision to save some bytes on texture coordinates and normals.</p>
<p>To describe the vertex sources, we have to create a <a class="el" href="class_ogre_1_1_vertex_data.html" title="collects together all the vertex-related information used to render geometry.">Ogre::VertexData</a> object. Notably it stores how many vertices we have.</p>
<div class="fragment"><div class="line">        mesh-&gt;sharedVertexData = <span class="keyword">new</span> VertexData();</div>
<div class="line">        mesh-&gt;sharedVertexData-&gt;vertexCount = 4;</div>
<div class="line">        VertexDeclaration* decl = mesh-&gt;sharedVertexData-&gt;vertexDeclaration;</div>
<div class="line">        VertexBufferBinding* bind = mesh-&gt;sharedVertexData-&gt;vertexBufferBinding;</div>
</div><!-- fragment --><p> The actual description of our vertex buffer however is stored inside the <a class="el" href="class_ogre_1_1_vertex_declaration.html" title="This class declares the format of a set of vertex inputs, which can be issued to the rendering API th...">Ogre::VertexDeclaration</a>.</p>
<div class="fragment"><div class="line">        <span class="keywordtype">size_t</span> offset = 0;</div>
<div class="line">        offset += decl-&gt;addElement(0, offset, <a class="code" href="group___render_system.html#gga027109503a988ba85f4c63b55082907fa9ccf920d2572b15896f75ccf30fb150c">VET_FLOAT3</a>, <a class="code" href="group___render_system.html#gga0a62b3f2ede8992ff365bb013a8bc00dad04d50e91c2ec5377e610b3f5b9b07f2">VES_POSITION</a>).getSize();</div>
<div class="line">        offset += decl-&gt;addElement(0, offset, <a class="code" href="group___render_system.html#gga027109503a988ba85f4c63b55082907fa9ccf920d2572b15896f75ccf30fb150c">VET_FLOAT3</a>, <a class="code" href="group___render_system.html#gga0a62b3f2ede8992ff365bb013a8bc00da1dec7d36a64625348e23af26c9231227">VES_NORMAL</a>).getSize();</div>
<div class="line">        offset += decl-&gt;addElement(0, offset, <a class="code" href="group___render_system.html#gga027109503a988ba85f4c63b55082907fa0993ccf616ec6e7bf60fff2ef1705ce6">VET_FLOAT2</a>, <a class="code" href="group___render_system.html#gga0a62b3f2ede8992ff365bb013a8bc00da17abb855311f3a67bc31414cad8d6212">VES_TEXTURE_COORDINATES</a>, 0).getSize();</div>
<div class="ttc" id="agroup___render_system_html_gga027109503a988ba85f4c63b55082907fa0993ccf616ec6e7bf60fff2ef1705ce6"><div class="ttname"><a href="group___render_system.html#gga027109503a988ba85f4c63b55082907fa0993ccf616ec6e7bf60fff2ef1705ce6">Ogre::VET_FLOAT2</a></div><div class="ttdeci">@ VET_FLOAT2</div><div class="ttdef"><b>Definition:</b> OgreHardwareVertexBuffer.h:126</div></div>
<div class="ttc" id="agroup___render_system_html_gga027109503a988ba85f4c63b55082907fa9ccf920d2572b15896f75ccf30fb150c"><div class="ttname"><a href="group___render_system.html#gga027109503a988ba85f4c63b55082907fa9ccf920d2572b15896f75ccf30fb150c">Ogre::VET_FLOAT3</a></div><div class="ttdeci">@ VET_FLOAT3</div><div class="ttdef"><b>Definition:</b> OgreHardwareVertexBuffer.h:127</div></div>
<div class="ttc" id="agroup___render_system_html_gga0a62b3f2ede8992ff365bb013a8bc00da17abb855311f3a67bc31414cad8d6212"><div class="ttname"><a href="group___render_system.html#gga0a62b3f2ede8992ff365bb013a8bc00da17abb855311f3a67bc31414cad8d6212">Ogre::VES_TEXTURE_COORDINATES</a></div><div class="ttdeci">@ VES_TEXTURE_COORDINATES</div><div class="ttdoc">Texture coordinates, typically VET_FLOAT2.</div><div class="ttdef"><b>Definition:</b> OgreHardwareVertexBuffer.h:103</div></div>
<div class="ttc" id="agroup___render_system_html_gga0a62b3f2ede8992ff365bb013a8bc00da1dec7d36a64625348e23af26c9231227"><div class="ttname"><a href="group___render_system.html#gga0a62b3f2ede8992ff365bb013a8bc00da1dec7d36a64625348e23af26c9231227">Ogre::VES_NORMAL</a></div><div class="ttdeci">@ VES_NORMAL</div><div class="ttdoc">Normal, typically VET_FLOAT3.</div><div class="ttdef"><b>Definition:</b> OgreHardwareVertexBuffer.h:97</div></div>
<div class="ttc" id="agroup___render_system_html_gga0a62b3f2ede8992ff365bb013a8bc00dad04d50e91c2ec5377e610b3f5b9b07f2"><div class="ttname"><a href="group___render_system.html#gga0a62b3f2ede8992ff365bb013a8bc00dad04d50e91c2ec5377e610b3f5b9b07f2">Ogre::VES_POSITION</a></div><div class="ttdeci">@ VES_POSITION</div><div class="ttdoc">Position, typically VET_FLOAT3.</div><div class="ttdef"><b>Definition:</b> OgreHardwareVertexBuffer.h:91</div></div>
</div><!-- fragment --><p> Now we can continue to create the Hardware Buffers and upload our data.</p>
<div class="fragment"><div class="line">        <a class="code" href="namespace_ogre.html#a23079674b2abb8481c373860bca2c22a">HardwareVertexBufferPtr</a> vbuf =</div>
<div class="line">            HardwareBufferManager::getSingleton().createVertexBuffer(offset, 4, <a class="code" href="group___render_system.html#gga3e7bd12438696e8c75150be1fbe90532ad4ea5a32caed7bbb643f6536606dba64">HBU_GPU_ONLY</a>);</div>
<div class="line">        vbuf-&gt;<a class="code" href="class_ogre_1_1_hardware_buffer.html#ad310f05bf1a2d5cff6250ba13160c645">writeData</a>(0, vbuf-&gt;getSizeInBytes(), vertices, <span class="keyword">true</span>);</div>
<div class="line">        bind-&gt;setBinding(0, vbuf);</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="namespace_ogre.html#a29417692403e4e51f1c892c643ff4165">HardwareIndexBufferPtr</a> ibuf =</div>
<div class="line">            HardwareBufferManager::getSingleton().createIndexBuffer(HardwareIndexBuffer::IT_16BIT, 6, <a class="code" href="group___render_system.html#gga3e7bd12438696e8c75150be1fbe90532ad4ea5a32caed7bbb643f6536606dba64">HBU_GPU_ONLY</a>);</div>
<div class="line">        ibuf-&gt;writeData(0, ibuf-&gt;getSizeInBytes(), faces, <span class="keyword">true</span>);</div>
<div class="ttc" id="aclass_ogre_1_1_hardware_buffer_html_ad310f05bf1a2d5cff6250ba13160c645"><div class="ttname"><a href="class_ogre_1_1_hardware_buffer.html#ad310f05bf1a2d5cff6250ba13160c645">Ogre::HardwareBuffer::writeData</a></div><div class="ttdeci">virtual void writeData(size_t offset, size_t length, const void *pSource, bool discardWholeBuffer=false)</div><div class="ttdoc">Writes data to the buffer from an area of system memory; note that you must ensure that your buffer i...</div><div class="ttdef"><b>Definition:</b> OgreHardwareBuffer.h:298</div></div>
<div class="ttc" id="agroup___render_system_html_gga3e7bd12438696e8c75150be1fbe90532ad4ea5a32caed7bbb643f6536606dba64"><div class="ttname"><a href="group___render_system.html#gga3e7bd12438696e8c75150be1fbe90532ad4ea5a32caed7bbb643f6536606dba64">Ogre::HBU_GPU_ONLY</a></div><div class="ttdeci">@ HBU_GPU_ONLY</div><div class="ttdoc">Device-local GPU (video) memory.</div><div class="ttdef"><b>Definition:</b> OgreHardwareBuffer.h:71</div></div>
<div class="ttc" id="anamespace_ogre_html_a23079674b2abb8481c373860bca2c22a"><div class="ttname"><a href="namespace_ogre.html#a23079674b2abb8481c373860bca2c22a">Ogre::HardwareVertexBufferPtr</a></div><div class="ttdeci">SharedPtr&lt; HardwareVertexBuffer &gt; HardwareVertexBufferPtr</div><div class="ttdef"><b>Definition:</b> OgrePrerequisites.h:290</div></div>
<div class="ttc" id="anamespace_ogre_html_a29417692403e4e51f1c892c643ff4165"><div class="ttname"><a href="namespace_ogre.html#a29417692403e4e51f1c892c643ff4165">Ogre::HardwareIndexBufferPtr</a></div><div class="ttdeci">SharedPtr&lt; HardwareIndexBuffer &gt; HardwareIndexBufferPtr</div><div class="ttdef"><b>Definition:</b> OgrePrerequisites.h:288</div></div>
</div><!-- fragment --><p> Note how we used the symbolical constant <code>0</code> to link the <a class="el" href="class_ogre_1_1_hardware_vertex_buffer.html" title="Specialisation of HardwareBuffer for a vertex buffer.">Ogre::HardwareVertexBuffer</a> to the <a class="el" href="class_ogre_1_1_vertex_declaration.html" title="This class declares the format of a set of vertex inputs, which can be issued to the rendering API th...">Ogre::VertexDeclaration</a>. This allows the underlying RenderSystem to swap VertexBuffers without changing the VertexDeclaration. i.e. render different Meshes that share the same vertex layout, without changing the state.</p>
<p>Finally we create the <a class="el" href="class_ogre_1_1_sub_mesh.html" title="Defines a part of a complete mesh.">Ogre::SubMesh</a> that will be ultimately rendered.</p>
<div class="fragment"><div class="line">        SubMesh* sub = mesh-&gt;createSubMesh();</div>
<div class="line">        sub-&gt;useSharedVertices = <span class="keyword">true</span>;</div>
<div class="line">        sub-&gt;indexData-&gt;indexBuffer = ibuf;</div>
<div class="line">        sub-&gt;indexData-&gt;indexCount = 6;</div>
<div class="line">        sub-&gt;indexData-&gt;indexStart = 0;</div>
</div><!-- fragment --><p> Note that while our VertexBuffer is shared, the IndexBuffer is not. This allows rendering different faces of the same object using different Materials. Here, each SubMesh links the faces (IndexBuffer) to the according material.</p>
<p>Finally, we have to update the loading state of the mesh as </p><div class="fragment"><div class="line">mesh-&gt;load();</div>
</div><!-- fragment --><p> If you have registered a <a class="el" href="class_ogre_1_1_manual_resource_loader.html" title="Interface describing a manual resource loader.">Ogre::ManualResourceLoader</a>, the resource loading would only happen now.</p>
<dl class="section note"><dt>Note</dt><dd>Using the <a class="el" href="class_ogre_1_1_manual_resource_loader.html" title="Interface describing a manual resource loader.">Ogre::ManualResourceLoader</a> is highly recommended. It allows lazy-loading the data on demand as well as unloading and re-loading resources when running out of memory. </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
